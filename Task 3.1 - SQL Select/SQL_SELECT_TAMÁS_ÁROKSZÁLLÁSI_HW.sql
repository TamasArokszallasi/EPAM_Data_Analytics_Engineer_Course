 --Part 1 / Write SQL queries to retrieve the following data

--Part 1-1 "All animation movies released between 2017 and 2019 with rate more than 1, alphabetical"

SELECT title 
FROM public.film 
	inner JOIN public.film_category ON public.film.film_id = public.film_category.film_id
	inner JOIN public.category ON public.film_category.category_id = public.category.category_id
WHERE release_year BETWEEN 2017 AND 2019 
    AND rental_rate > 1 
    AND LOWER(public.category.name) = LOWER('animation')  -- use the category name from the task description
ORDER BY title ASC;


--PART 1-2: The revenue earned by each rental store after March 2017 (columns: address and address2 – as one column, revenue)
-- COMMENT: We have to connect the tables to create a connected column where there is the full address, and another for the revenue part. 

SELECT CONCAT(public.address.address, ', ', public.address.address2) AS full_address, SUM(public.payment.amount) AS revenue 
FROM public.payment 
	INNER JOIN public.rental ON public.payment.rental_id = public.rental.rental_id
	INNER JOIN public.inventory ON public.rental.inventory_id = public.inventory.inventory_id
	INNER JOIN public.store ON public.inventory.store_id = public.store.store_id
	INNER JOIN public.address ON public.store.address_id = public.address.address_id
WHERE public.payment.payment_date > '2017-03-31'
GROUP BY public.store.store_id, full_address;



--PART 1-3 : Top-5 actors by number of movies (released after 2015) they took part in 
--(columns: first_name, last_name, number_of_movies, sorted by number_of_movies in descending order)

SELECT a.actor_id, a.first_name, a.last_name, COUNT(*) as number_of_movies
FROM public.actor a
INNER JOIN public.film_actor fa ON a.actor_id = fa.actor_id
INNER JOIN public.film f ON fa.film_Id = f.film_Id
WHERE f.release_year > 2015
GROUP BY a.actor_id
ORDER BY number_of_movies DESC, a.first_name ASC, a.last_name ASC
LIMIT 5;


--PART 1-4 : "Number of Drama, Travel, Documentary per year (columns: release_year, number_of_drama_movies, 
--number_of_travel_movies, number_of_documentary_movies), sorted by release year in descending order. 
--Dealing with NULL values is encouraged)"
--COMMENT: The LEFT JOIN was used to ensure that all films are included in the result, even if they don’t have a corresponding entry in the film_category or category tables.
--However, if we’re only interested in films that have a specific genre, we can use an just JOIN instead.
--As for the different spellings of the categories, we can use the LOWER function to make the category comparison case-insensitive. 
SELECT f.release_year,
       COUNT(CASE WHEN LOWER(c.name)='drama' THEN 1 ELSE NULL END) as number_of_drama_movies,
       COUNT(CASE WHEN LOWER(c.name)='travel' THEN 1 ELSE NULL END) as number_of_travel_movies,
       COUNT(CASE WHEN LOWER(c.name)='documentary' THEN 1 ELSE NULL END) as number_of_documentary_movies
FROM public.film f
inner JOIN public.film_category fc on fc.film_Id=f.film_Id
inner JOIN public.category c on c.category_Id=fc.category_Id
GROUP BY release_year
ORDER BY release_year DESC;

-- PART 2 / Solve the following problems using SQL

-- PART 2-1 : "Who were the top revenue-generating staff members in 2017? They should be rewarded with 
--a bonus for their performance. Please indicate which store the employee worked in. If he changed stores during 2017, 
--indicate the last one"
-- Join the payment and staff tables to get the revenue generated by each staff member,
-- then filter these records based on the payment date.
-- Use the store and address tables to get the address of the store.
-- Use a subquery to get the staff member with the highest revenue for each store.

WITH staff_revenue AS (
    SELECT s.staff_id, s.store_id, SUM(p.amount) AS revenue
    FROM public.payment p
    INNER JOIN public.staff s ON p.staff_id = s.staff_id
    WHERE EXTRACT(YEAR FROM p.payment_date) = 2017
    GROUP BY s.staff_id, s.store_id
),
max_revenue AS (
    SELECT store_id, MAX(revenue) AS max_revenue
    FROM staff_revenue
    GROUP BY store_id
)
SELECT s.first_name, s.last_name, a.address, sr.revenue
FROM staff_revenue sr
INNER JOIN max_revenue mr ON sr.store_id = mr.store_id AND sr.revenue = mr.max_revenue
INNER JOIN public.staff s ON sr.staff_id = s.staff_id
INNER JOIN public.store st ON s.store_id = st.store_id
INNER JOIN public.address a ON st.address_id = a.address_id
ORDER BY sr.revenue DESC;

-- PART 2-2: "Which 5 movies were rented more than others, and what's the expected age of the audience for these movies? 

-- Join the rental, inventory, and film tables to get the number of rentals for each movie.
-- Use a CASE statement to determine the expected age based on the film rating.

SELECT f.title, COUNT(*) as number_of_rentals, f.rating,
    CASE
        WHEN f.rating = 'G' THEN 'All ages'
        WHEN f.rating = 'PG' THEN '7+'
        WHEN f.rating = 'PG-13' THEN '13+'
        WHEN f.rating = 'R' THEN '17+'
        WHEN f.rating = 'NC-17' THEN '18+'
        ELSE 'No rating'
    END as expected_age
FROM public.rental r
    INNER JOIN public.inventory i ON r.inventory_id = i.inventory_id
    INNER JOIN public.film f ON i.film_id = f.film_id
GROUP BY f.film_id
ORDER BY number_of_rentals DESC LIMIT 5;


-- PART 3 / TASK: "Which actors/actresses didn't act for a longer period of time than the others? "

--PART 3-1: gap between the latest release_year and current year per each actor;
-- 
WITH actor_gap AS (
    SELECT a.actor_id, a.first_name, a.last_name, MAX(f.release_year) as latest_release_year, 
    DATE_PART('year', CURRENT_DATE) - MAX(f.release_year) as gap
    FROM public.actor a
        INNER JOIN public.film_actor fa ON a.actor_id = fa.actor_id
        INNER JOIN public.film f ON fa.film_Id = f.film_Id
    GROUP BY a.actor_id
)
SELECT actor_id, first_name, last_name, latest_release_year, gap
FROM actor_gap
WHERE gap = (SELECT MAX(gap) FROM actor_gap);



--PART 3 / V2: gaps between sequential films per each actor;
--This query first calculates the gap between the release years of any two sequential films 
--for each actor and then selects the actors where the maximum gap 
--is equal to the maximum gap found. This will return all actors who have the maximum gap
WITH actor_gap AS (
    SELECT 
        a1.actor_id,
        a1.first_name,
        a1.last_name,
        a2.release_year - a1.release_year as gap
    FROM 
        (SELECT fa.actor_id, a.first_name, a.last_name, f.release_year,
                ROW_NUMBER() OVER(PARTITION BY fa.actor_id ORDER BY f.release_year) as rn
         FROM public.film_actor fa
         INNER JOIN public.film f ON fa.film_id = f.film_id
         INNER JOIN public.actor a ON fa.actor_id = a.actor_id) a1
    INNER JOIN 
        (SELECT fa.actor_id, a.first_name, a.last_name, f.release_year,
                ROW_NUMBER() OVER(PARTITION BY fa.actor_id ORDER BY f.release_year) as rn
         FROM public.film_actor fa
         INNER JOIN public.film f ON fa.film_id = f.film_id
         INNER JOIN public.actor a ON fa.actor_id = a.actor_id) a2 
    ON a1.actor_id = a2.actor_id AND a2.rn = a1.rn + 1
)
SELECT actor_id, first_name, last_name, MAX(gap) as max_gap
FROM actor_gap
GROUP BY actor_id, first_name, last_name
HAVING MAX(gap) = (SELECT MAX(gap) FROM actor_gap);



-- PART 3/ V3: gap between the release of their first and last film
   -- So i calculate the gap for each actor, then find those whose gap equals to the max gap.

WITH actor_gap AS (
    SELECT 
        a.actor_id,
        a.first_name,
        a.last_name,
        MAX(f.release_year) - MIN(f.release_year) as gap
    FROM 
        public.film_actor fa
    INNER JOIN 
        public.film f ON fa.film_id = f.film_id
    INNER JOIN 
        public.actor a ON fa.actor_id = a.actor_id
    GROUP BY 
        a.actor_id
)
SELECT actor_id, first_name, last_name, gap
FROM actor_gap
WHERE gap = (SELECT MAX(gap) FROM actor_gap);


